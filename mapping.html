<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>mapping.utf8</title>

<script src="site_libs/jquery-1.12.4/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/spacelab.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/htmlwidgets-1.5.3/htmlwidgets.js"></script>
<link href="site_libs/leaflet-1.3.1/leaflet.css" rel="stylesheet" />
<script src="site_libs/leaflet-1.3.1/leaflet.js"></script>
<link href="site_libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet" />
<script src="site_libs/proj4-2.6.2/proj4.min.js"></script>
<script src="site_libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script>
<link href="site_libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet" />
<script src="site_libs/leaflet-binding-2.0.4.1/leaflet.js"></script>
<script src="site_libs/leaflet-providers-1.9.0/leaflet-providers_1.9.0.js"></script>
<script src="site_libs/leaflet-providers-plugin-2.0.4.1/leaflet-providers-plugin.js"></script>
<script src="site_libs/FlatGeoBuf-3.3.3/fgb.js"></script>
<script src="site_libs/FlatGeoBuf-3.3.3/flatgeobuf-geojson.min.js"></script>
<script src="site_libs/chromajs-2.1.0/chroma.min.js"></script>
<link id="sgdat-1-attachment" rel="attachment" href="site_libs/sgdat-0.0.1/sgdat_layer.fgb"/>
<link href="site_libs/HomeButton-0.0.1/home-button.css" rel="stylesheet" />
<script src="site_libs/HomeButton-0.0.1/home-button.js"></script>
<script src="site_libs/HomeButton-0.0.1/easy-button-src.min.js"></script>
<script src="site_libs/clipboard-0.0.1/setClipboardText.js"></script>
<link href="site_libs/mapviewCSS-0.0.1/mapview-popup.css" rel="stylesheet" />
<link href="site_libs/mapviewCSS-0.0.1/mapview.css" rel="stylesheet" />
<link id="alldat-Gear-1-attachment" rel="attachment" href="site_libs/alldat-Gear-0.0.1/alldat-Gear_layer.fgb"/>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


<link rel="stylesheet" href="css/styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 52px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 57px;
  margin-top: -57px;
}
.section h2 {
  padding-top: 57px;
  margin-top: -57px;
}
.section h3 {
  padding-top: 57px;
  margin-top: -57px;
}
.section h4 {
  padding-top: 57px;
  margin-top: -57px;
}
.section h5 {
  padding-top: 57px;
  margin-top: -57px;
}
.section h6 {
  padding-top: 57px;
  margin-top: -57px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">TBEP R Training</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="R_Basics.html">
    <span class="fas fa-university"></span>
     
    R Basics
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fas fa-wrench"></span>
     
    Data wrangling
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Data_Wrangling_1.html">Part 1</a>
    </li>
    <li>
      <a href="Data_Wrangling_2.html">Part 2</a>
    </li>
  </ul>
</li>
<li>
  <a href="Viz_and_Graphics.html">
    <span class="fas fa-chart-line"></span>
     
    Viz and graphics
  </a>
</li>
<li>
  <a href="mapping.html">
    <span class="fas fa-globe-americas"></span>
     
    Spatial analysis and mapping
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="Data_and_Resources.html">
    <span class="fas fa-list"></span>
     
    Data and resources
  </a>
</li>
<li>
  <a href="https://github.com/tbep-tech/tbep-r-training">
    <span class="fas fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<script src="js/hideoutput.js"></script>
<div id="spatial-data-analysis-and-mapping" class="section level1">
<h1>Spatial data analysis and mapping</h1>
<p>Get the lesson R script: <a href="mapping.R">mapping.R</a></p>
<p>Get the lesson data: <a href="data/data.zip">download zip</a></p>
<div id="lesson-outline" class="section level2">
<h2>Lesson Outline</h2>
<ul>
<li><a href="#vector-data">Vector data</a></li>
<li><a href="#simple-features">Simple features</a></li>
<li><a href="#creating-spatial-data-with-simple-features">Creating spatial data with simple features</a></li>
<li><a href="#basic-geospatial-analysis">Basic geospatial analysis</a></li>
<li><a href="#quick-mapping">Quick mapping</a></li>
</ul>
</div>
<div id="lesson-exercises" class="section level2">
<h2>Lesson Exercises</h2>
<ul>
<li><a href="#exercise-12">Exercise 12</a></li>
<li><a href="#exercise-13">Exercise 13</a></li>
<li><a href="#exercise-14">Exercise 14</a></li>
</ul>
<p>R has been around for over twenty years and most of its use has focused on statistical analysis. Tools for spatial analysis have been developed in recent years that allow the use of R as a full-blown GIS with capabilities similar or even superior to commerical software. This lesson will focus on geospatial analysis using the <a href="https://r-spatial.github.io/sf/" target="_blank">simple features</a> package. We will focus entirely on working with vector data in this lesson, but checkout the <a href="https://cran.r-project.org/web/packages/raster/" target="_blank">raster</a> and <a href="https://cran.r-project.org/web/packages/rgdal/index.html" target="_blank">rgdal</a> packages if you want to work with raster data in R. There are several useful vignettes in the raster link.</p>
<p>The goals for today are:</p>
<ol style="list-style-type: decimal">
<li><p>Understand the vector data structure</p></li>
<li><p>Understand how to import and structure vector data in R</p></li>
<li><p>Understand how R stores spatial data using the simple features package</p></li>
<li><p>Execute basic geospatial functions in R</p></li>
</ol>
</div>
<div id="vector-data" class="section level2">
<h2>Vector data</h2>
<p>Most of us are probably familiar with the basic types of spatial data and their components. We’re going to focus entirely on vector data for this lesson because these data are easily conceptualized as <strong>features</strong> or discrete objects with spatial information. We’ll discuss some of the details about this later. Raster data by contrast are stored in a regular grid where the cells of the grid are associated with values. Raster data are more common for data with continuous coverage, such as climate or weather layers.</p>
<p>Vector data come in three flavors. The simplest is a <strong>point</strong>, which is a 0-dimensional feature that can be used to represent a specific location on the earth, such as a single tree or an entire city. Linear, 1-dimensional features can be represented with points (or vertices) that are connected by a path to form a <strong>line</strong> and when many points are connected these form a <strong>polyline</strong>. Finally, when a polyline’s path returns to its origin to represent an enclosed 2-dimensional space, such as a forest, watershed boundary, or lake, this forms a <strong>polygon</strong>.</p>
<p><img src="figure/pts-lines-polys.png" /></p>
<p><em>Image <a href="https://earthdatascience.org/courses/earth-analytics/spatial-data-r/intro-vector-data-r/" target="_blank">source</a></em></p>
<p>All vector data are represented similarly, whether they’re points, lines or polygons. Points are defined by a single coordinate location, whereas a line or polygon is several points with a grouping variable that distinguishes one object from another. In all cases, the aggregate dataset is composed of one or more features of the same type (points, lines, or polygons).</p>
<p>There are two other pieces of information that are included with vector data. The <strong>attributes</strong> that can be associated with each feature and the <strong>coordinate reference system</strong> or <strong>CRS</strong>. The attributes can be any supporting information about a feature, such as a text description or summary data about the features. You can identify attributes as anything in a spatial dataset that is not explicitly used to define the location of the features.</p>
<p>The CRS is used to establish a frame of reference for the locations in your spatial data. The chosen CRS ensures that all features are correctly referenced relative to each other, especially between different datasets. As a simple example, imagine comparing length measurements for two objects where one was measured in centimeters and another in inches. If you didn’t know the unit of measurement, you could not compare relative lengths. The CRS is similar in that it establishes a common frame of reference, but for spatial data. An added complication with spatial data is that location can be represented in both 2-dimensional or 3-dimensional space. This is beyond the scope of this lesson, but for any geospatial analysis you should be sure that:</p>
<ol style="list-style-type: decimal">
<li><p>the CRS is the same when comparing datasets, and</p></li>
<li><p>the CRS is appropriate for the region you’re looking at.</p></li>
</ol>
<p><img src="figure/crs-comparisons.jpg" /></p>
<p><em>Image <a href="https://nceas.github.io/oss-lessons/spatial-data-gis-law/1-mon-spatial-data-intro.html" target="_blank">source</a></em></p>
<p>To summarize, vector data include the following:</p>
<ol style="list-style-type: decimal">
<li><p>spatial data (e.g., latitude, longitude) as points, lines, or polygons</p></li>
<li><p>attributes</p></li>
<li><p>a coordinate reference system</p></li>
</ol>
<p>These are all the pieces of information you need to recognize in your data when working with features in R.</p>
</div>
<div id="simple-features" class="section level2">
<h2>Simple features</h2>
<p>R has a long history of packages for working with spatial data. For many years, the <a href="https://cran.r-project.org/web/packages/sp/index.html" target="_blank">sp</a> package was the standard and most widely used toolset for working with spatial data in R. This package laid the foundation for creating spatial data classes and methods in R, but unfortunately its development predated a lot of the newer tools that are built around the <a href="https://www.tidyverse.org/" target="_blank">tidyverse</a>. This makes it incredibly difficult to incorporate <code>sp</code> data objects with these newer data analysis workflows.</p>
<p>The <a href="https://r-spatial.github.io/sf/" target="_blank">simple features</a> or sf package was developed to streamline the use of spatial data in R and to align its functionality with those provided in the tidyverse. The sf package is already beginning to replace sp as the fundamental spatial model in R for vector data. A major advantage of sf, as you’ll see, is its intuitive data structure that retains many familiar components of the <code>data.frame</code> (or more accurately, <code>tibble</code>).</p>
<p>Simple Features is a hierarchical data model that represents a wide range of geometry types - it includes all common vector geometry types (but does not include raster) and even allows geometry collections, which can have multiple geometry types in a single object. From the first sf package vignette we see:</p>
<p><img src="figure/sf_objects.png" /></p>
<p>You’ll notice that these are the same features we described above, with the addition of “multi” features and geometry collections that include more than one type of feature.</p>
</div>
<div id="exercise-12" class="section level2">
<h2>Exercise 12</h2>
<p>Let’s get setup for this lesson. We’ll make sure we have the necessary packages installed and loaded. Then we’ll import our datasets.</p>
<ol style="list-style-type: decimal">
<li><p>Open a new script in your RStudio project or within RStudio cloud.</p></li>
<li><p>At the top of the script, load the <code>tidyverse</code>, <code>sf</code>, and <code>mapview</code> libraries. Don’t forget you can use <code>install.packages(c('tidyverse', 'sf', 'mapview'))</code> if the packages aren’t installed.</p></li>
<li><p>Load the <code>fishdat.csv</code>, <code>statloc.csv</code>, and <code>sgdat.shp</code> datasets from your data folder. For the csv files, use <code>read_csv()</code> and for the shapefile, use the <code>st_read()</code> function from the <code>sf</code> package. The shapefile is seagrass polygon data for Old Tampa Bay in 2016. As before, assign each loaded dataset to an object in your workspace.</p></li>
</ol>
<div class="fold s o">
<pre class="r"><code># load libraries
library(tidyverse)
library(sf)
library(mapview)

# load the fish data
fishdat &lt;- read_csv(&#39;data/fishdat.csv&#39;)

# load the station data
statloc &lt;- read_csv(&#39;data/statloc.csv&#39;)

# load the sgdat shapefile
sgdat &lt;- st_read(&#39;data/sgdat.shp&#39;)</code></pre>
</div>
</div>
<div id="creating-spatial-data-with-simple-features" class="section level2">
<h2>Creating spatial data with simple features</h2>
<p>Now that we’re setup, let’s talk about how the <code>sf</code> package can be used. After the package is loaded, you can check out all of the methods that are available for <code>sf</code> data objects. Many of these names will look familiar if you’ve done geospatial analysis before. We’ll use some of these a little bit later.</p>
<pre class="r"><code>methods(class = &#39;sf&#39;)</code></pre>
<pre><code>##  [1] [                     [[&lt;-                  $&lt;-                  
##  [4] aggregate             anti_join             arrange              
##  [7] as.data.frame         cbind                 coerce               
## [10] dbDataType            dbWriteTable          distinct             
## [13] dplyr_reconstruct     filter                full_join            
## [16] gather                group_by              group_split          
## [19] identify              initialize            inner_join           
## [22] left_join             mapView               merge                
## [25] mutate                nest                  plot                 
## [28] print                 rbind                 rename               
## [31] right_join            rowwise               sample_frac          
## [34] sample_n              select                semi_join            
## [37] separate_rows         separate              show                 
## [40] slice                 slotsFromS3           spread               
## [43] st_agr                st_agr&lt;-              st_area              
## [46] st_as_s2              st_as_sf              st_bbox              
## [49] st_boundary           st_buffer             st_cast              
## [52] st_centroid           st_collection_extract st_convex_hull       
## [55] st_coordinates        st_crop               st_crs               
## [58] st_crs&lt;-              st_difference         st_filter            
## [61] st_geometry           st_geometry&lt;-         st_interpolate_aw    
## [64] st_intersection       st_intersects         st_is_valid          
## [67] st_is                 st_join               st_line_merge        
## [70] st_m_range            st_make_valid         st_nearest_points    
## [73] st_node               st_normalize          st_point_on_surface  
## [76] st_polygonize         st_precision          st_reverse           
## [79] st_sample             st_segmentize         st_set_precision     
## [82] st_shift_longitude    st_simplify           st_snap              
## [85] st_sym_difference     st_transform          st_triangulate       
## [88] st_union              st_voronoi            st_wrap_dateline     
## [91] st_write              st_z_range            st_zm                
## [94] summarise             transform             transmute            
## [97] ungroup               unite                 unnest               
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>All of the functions and methods in sf are prefixed with st_, which stands for ‘spatial and temporal’. This is kind of confusing but this is in reference to standard methods available in <a href="https://en.wikipedia.org/wiki/PostGIS" target="_blank">PostGIS</a>, an open-source backend that is used by many geospatial platforms. An advantage of this prefixing is all commands are easy to find with command-line completion in sf, in addition to having naming continuity with existing software.</p>
<p>There are two ways to create a spatial data object in R, i.e., an <code>sf</code> object, using the sf package.</p>
<ol style="list-style-type: decimal">
<li><p>Directly import a shapefile</p></li>
<li><p>Convert an existing R object with latitude/longitude data that represent point features</p></li>
</ol>
<p>We’ve already imported a shapefile in exercise 12, so let’s look at its structure to better understand the <code>sf</code> object. The <code>st_read()</code> function can be used for import. Setting <code>quiet = T</code> will keep R from being chatty when it imports the data.</p>
<pre class="r"><code>sgdat &lt;- st_read(&#39;data/sgdat.shp&#39;, quiet = T)
sgdat</code></pre>
<pre><code>## Simple feature collection with 575 features and 2 fields
## geometry type:  POLYGON
## dimension:      XY
## bbox:           xmin: -82.72462 ymin: 27.81386 xmax: -82.48426 ymax: 28.03548
## geographic CRS: WGS 84
## First 10 features:
##    OBJECTID FLUCCS                       geometry
## 1       211   9113 POLYGON ((-82.64982 28.0200...
## 2       396   9116 POLYGON ((-82.60445 27.9828...
## 3       398   9113 POLYGON ((-82.58985 27.8230...
## 4       399   9113 POLYGON ((-82.62025 27.9946...
## 5       416   9116 POLYGON ((-82.62363 28.0001...
## 6       451   9113 POLYGON ((-82.58943 27.8232...
## 7       491   9113 POLYGON ((-82.60703 27.8742...
## 8       499   9113 POLYGON ((-82.54753 27.9595...
## 9       515   9116 POLYGON ((-82.53872 27.8979...
## 10      539   9113 POLYGON ((-82.54837 27.9617...</code></pre>
<p>What does this show us? Let’s break it down.</p>
<p><img src="figure/sf_struct.png" /></p>
<ul>
<li>In green, metadata describing components of the <code>sf</code> object</li>
<li>In yellow, a simple feature: a single record, or <code>data.frame</code> row, consisting of attributes and geometry</li>
<li>In blue, a single simple feature geometry (an object of class <code>sfg</code>)</li>
<li>In red, a simple feature list-column (an object of class <code>sfc</code>, which is a column in the data.frame)</li>
</ul>
<p>We’ve just imported a polygon dataset with 575 features and 2 fields. The dataset is projected using the WGS 84 geographic CRS (i.e., latitude/longitude). You’ll notice that the actual dataset looks very similar to a regular <code>data.frame</code>, with some interesting additions. The header includes some metadata about the <code>sf</code> object and the <code>geometry</code> column includes the actual spatial information for each feature. Conceptually, you can treat the <code>sf</code> object like you would a <code>data.frame</code>.</p>
<p>Easy enough, but what if we have point data that’s not a shapefile? You can create an <code>sf</code> object from any existing <code>data.frame</code> so long as the data include coordinate information (e.g., columns for longitude and latitude) and you know the CRS (or can make an educated guess). We can do this with our <code>fishdat</code> and <code>statloc</code> csv files that we imported.</p>
<pre class="r"><code>str(fishdat)</code></pre>
<pre><code>## spec_tbl_df [2,844 × 12] (S3: spec_tbl_df/tbl_df/tbl/data.frame)
##  $ OBJECTID     : num [1:2844] 1550020 1550749 1550750 1550762 1550828 ...
##  $ Reference    : chr [1:2844] &quot;TBM1996032006&quot; &quot;TBM1996032004&quot; &quot;TBM1996032004&quot; &quot;TBM1996032207&quot; ...
##  $ Sampling_Date: Date[1:2844], format: &quot;1996-03-20&quot; &quot;1996-03-20&quot; ...
##  $ yr           : num [1:2844] 1996 1996 1996 1996 1996 ...
##  $ Gear         : num [1:2844] 300 22 22 20 160 300 300 300 300 22 ...
##  $ ExDate       : POSIXct[1:2844], format: &quot;2018-04-12 10:27:38&quot; &quot;2018-04-12 10:25:23&quot; ...
##  $ Bluefish     : num [1:2844] 0 0 0 0 0 0 0 0 0 0 ...
##  $ Common Snook : num [1:2844] 0 0 0 0 0 0 0 0 0 0 ...
##  $ Mullets      : num [1:2844] 0 0 0 0 0 0 0 0 0 0 ...
##  $ Pinfish      : num [1:2844] 0 54 0 80 0 0 0 0 1 1 ...
##  $ Red Drum     : num [1:2844] 0 0 1 0 4 0 0 0 0 0 ...
##  $ Sand Seatrout: num [1:2844] 1 0 0 0 0 1 5 66 0 0 ...
##  - attr(*, &quot;spec&quot;)=
##   .. cols(
##   ..   OBJECTID = [32mcol_double()[39m,
##   ..   Reference = [31mcol_character()[39m,
##   ..   Sampling_Date = [34mcol_date(format = &quot;&quot;)[39m,
##   ..   yr = [32mcol_double()[39m,
##   ..   Gear = [32mcol_double()[39m,
##   ..   ExDate = [34mcol_datetime(format = &quot;&quot;)[39m,
##   ..   Bluefish = [32mcol_double()[39m,
##   ..   `Common Snook` = [32mcol_double()[39m,
##   ..   Mullets = [32mcol_double()[39m,
##   ..   Pinfish = [32mcol_double()[39m,
##   ..   `Red Drum` = [32mcol_double()[39m,
##   ..   `Sand Seatrout` = [32mcol_double()[39m
##   .. )</code></pre>
<pre class="r"><code>str(statloc)</code></pre>
<pre><code>## spec_tbl_df [2,173 × 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)
##  $ Reference: chr [1:2173] &quot;TBM1996032006&quot; &quot;TBM1996032004&quot; &quot;TBM1996032207&quot; &quot;TBM1996042601&quot; ...
##  $ Latitude : num [1:2173] 27.9 27.9 27.9 28 27.9 ...
##  $ Longitude: num [1:2173] -82.6 -82.6 -82.5 -82.7 -82.6 ...
##  - attr(*, &quot;spec&quot;)=
##   .. cols(
##   ..   Reference = [31mcol_character()[39m,
##   ..   Latitude = [32mcol_double()[39m,
##   ..   Longitude = [32mcol_double()[39m
##   .. )</code></pre>
<p>The <code>st_as_sf()</code> function can be used to make this <code>data.frame</code> into a <code>sf</code> object, but we first have to join the two datasets and tell R which column is the x-coordinates and which is the y-coordinates. We also have to specify a CRS - this is just a text string or number (i.e, EPSG) in a standard format for geospatial data. A big part of working with spatial data is keeping track of reference systems between different datasets. Remember that meaningful comparisons between datasets are only possible if the CRS is shared.</p>
<p>There are many, many types of reference systems and plenty of resources online that provide detailed explanations of the what and why behind the CRS (see <a href="http://www.spatialreference.org/" target="_blank">spatialreference.org</a> or <a href="https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/OverviewCoordinateReferenceSystems.pdf" target="_blank">this guide</a> from NCEAS). For now, just realize that we can use a simple text string in R to indicate which CRS we want. Although this may not always be true, we can make an educated guess that the standard geographic projection with the WGS84 datum applies to our dataset.</p>
</div>
<div id="exercise-13" class="section level2">
<h2>Exercise 13</h2>
<p>Let’s join the <code>fishdat</code> and <code>statloc</code> datasets and create an <code>sf</code> object using <code>st_as_sf()</code> function.</p>
<ol style="list-style-type: decimal">
<li><p>Join <code>fishdat</code> to <code>statloc</code> using the <code>left_join()</code> function with <code>by = "Reference"</code> as the key.</p></li>
<li><p>Use <code>st_as_sf()</code> to make the joined dataset an <code>sf</code> object. There are two arguments you need to specify with <code>st_as_sf()</code>: <code>coords = c('Longitude', 'Latitude')</code> so R knows which columns in your dataset are the x/y coordinates and <code>crs = 4326</code> to specifiy the CRS as WGS 84.</p></li>
<li><p>When you’re done, inspect the dataset. How many features are there? What type of spatial object is this?</p></li>
</ol>
<div class="fold s o">
<pre class="r"><code># Join the data
alldat &lt;- left_join(fishdat, statloc, by = &#39;Reference&#39;)

# create spatial data object
alldat &lt;- st_as_sf(alldat, coords = c(&#39;Longitude&#39;, &#39;Latitude&#39;), crs = 4326)

# examine the sf objec
alldat
str(alldat)</code></pre>
</div>
<p>There’s a shortcut to specifying the CRS if you don’t know which one to use. Remember, for spatial anlaysis make sure to only work with datasets that have the same projections and coordinate systems. The <code>st_crs()</code> function tells us the CRS for an existing <code>sf</code> obj.</p>
<pre class="r"><code># check crs
st_crs(alldat)</code></pre>
<pre><code>## Coordinate Reference System:
##   User input: EPSG:4326 
##   wkt:
## GEOGCRS[&quot;WGS 84&quot;,
##     DATUM[&quot;World Geodetic System 1984&quot;,
##         ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563,
##             LENGTHUNIT[&quot;metre&quot;,1]]],
##     PRIMEM[&quot;Greenwich&quot;,0,
##         ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],
##     CS[ellipsoidal,2],
##         AXIS[&quot;geodetic latitude (Lat)&quot;,north,
##             ORDER[1],
##             ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],
##         AXIS[&quot;geodetic longitude (Lon)&quot;,east,
##             ORDER[2],
##             ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],
##     USAGE[
##         SCOPE[&quot;unknown&quot;],
##         AREA[&quot;World&quot;],
##         BBOX[-90,-180,90,180]],
##     ID[&quot;EPSG&quot;,4326]]</code></pre>
<p>When we created the <code>alldat</code> dataset, we could have used the CRS from the <code>sgdat</code> object that we created in exercise 12 by using <code>crs = st_crs(sgdat)</code> for the <code>crs</code> argument. This is often a quick shortcut for creating an <code>sf</code> object without having to look up the CRS number.</p>
<p>We can verify that both now have the same CRS.</p>
<pre class="r"><code># verify the polygon and point data have the same crs
st_crs(sgdat)</code></pre>
<pre><code>## Coordinate Reference System:
##   User input: WGS 84 
##   wkt:
## GEOGCRS[&quot;WGS 84&quot;,
##     DATUM[&quot;World Geodetic System 1984&quot;,
##         ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563,
##             LENGTHUNIT[&quot;metre&quot;,1]]],
##     PRIMEM[&quot;Greenwich&quot;,0,
##         ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],
##     CS[ellipsoidal,2],
##         AXIS[&quot;latitude&quot;,north,
##             ORDER[1],
##             ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],
##         AXIS[&quot;longitude&quot;,east,
##             ORDER[2],
##             ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],
##     ID[&quot;EPSG&quot;,4326]]</code></pre>
<pre class="r"><code>st_crs(alldat)</code></pre>
<pre><code>## Coordinate Reference System:
##   User input: EPSG:4326 
##   wkt:
## GEOGCRS[&quot;WGS 84&quot;,
##     DATUM[&quot;World Geodetic System 1984&quot;,
##         ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563,
##             LENGTHUNIT[&quot;metre&quot;,1]]],
##     PRIMEM[&quot;Greenwich&quot;,0,
##         ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],
##     CS[ellipsoidal,2],
##         AXIS[&quot;geodetic latitude (Lat)&quot;,north,
##             ORDER[1],
##             ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],
##         AXIS[&quot;geodetic longitude (Lon)&quot;,east,
##             ORDER[2],
##             ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]],
##     USAGE[
##         SCOPE[&quot;unknown&quot;],
##         AREA[&quot;World&quot;],
##         BBOX[-90,-180,90,180]],
##     ID[&quot;EPSG&quot;,4326]]</code></pre>
<p>Finally, you may often want to use another coordinate system, such as a projection that is regionally-specific. You can use the <code>st_transform()</code> function to quickly change and/or reproject an <code>sf</code> object. For example, if we want to convert a geographic to UTM projection:</p>
<pre class="r"><code>alldatutm &lt;- alldat %&gt;% 
  st_transform(crs = &#39;+proj=utm +zone=17 +datum=NAD83 +units=m +no_defs&#39;)
st_crs(alldatutm)</code></pre>
<pre><code>## Coordinate Reference System:
##   User input: +proj=utm +zone=17 +datum=NAD83 +units=m +no_defs 
##   wkt:
## PROJCRS[&quot;unknown&quot;,
##     BASEGEOGCRS[&quot;unknown&quot;,
##         DATUM[&quot;North American Datum 1983&quot;,
##             ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101,
##                 LENGTHUNIT[&quot;metre&quot;,1]],
##             ID[&quot;EPSG&quot;,6269]],
##         PRIMEM[&quot;Greenwich&quot;,0,
##             ANGLEUNIT[&quot;degree&quot;,0.0174532925199433],
##             ID[&quot;EPSG&quot;,8901]]],
##     CONVERSION[&quot;UTM zone 17N&quot;,
##         METHOD[&quot;Transverse Mercator&quot;,
##             ID[&quot;EPSG&quot;,9807]],
##         PARAMETER[&quot;Latitude of natural origin&quot;,0,
##             ANGLEUNIT[&quot;degree&quot;,0.0174532925199433],
##             ID[&quot;EPSG&quot;,8801]],
##         PARAMETER[&quot;Longitude of natural origin&quot;,-81,
##             ANGLEUNIT[&quot;degree&quot;,0.0174532925199433],
##             ID[&quot;EPSG&quot;,8802]],
##         PARAMETER[&quot;Scale factor at natural origin&quot;,0.9996,
##             SCALEUNIT[&quot;unity&quot;,1],
##             ID[&quot;EPSG&quot;,8805]],
##         PARAMETER[&quot;False easting&quot;,500000,
##             LENGTHUNIT[&quot;metre&quot;,1],
##             ID[&quot;EPSG&quot;,8806]],
##         PARAMETER[&quot;False northing&quot;,0,
##             LENGTHUNIT[&quot;metre&quot;,1],
##             ID[&quot;EPSG&quot;,8807]],
##         ID[&quot;EPSG&quot;,16017]],
##     CS[Cartesian,2],
##         AXIS[&quot;(E)&quot;,east,
##             ORDER[1],
##             LENGTHUNIT[&quot;metre&quot;,1,
##                 ID[&quot;EPSG&quot;,9001]]],
##         AXIS[&quot;(N)&quot;,north,
##             ORDER[2],
##             LENGTHUNIT[&quot;metre&quot;,1,
##                 ID[&quot;EPSG&quot;,9001]]]]</code></pre>
</div>
<div id="basic-geospatial-analysis" class="section level2">
<h2>Basic geospatial analysis</h2>
<p>As with any analysis, let’s take a look at the data to see what we’re dealing with before we start comparing the two.</p>
<pre class="r"><code>plot(alldat)</code></pre>
<p><img src="mapping_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<pre class="r"><code>plot(sgdat)</code></pre>
<p><img src="mapping_files/figure-html/unnamed-chunk-9-2.png" width="672" /></p>
<p>So we have lots of stations where fish have been caught and lots of polygons for seagrass. You’ll also notice that the default plotting method for <code>sf</code> objects is to create one plot per attribute feature. This is intended behavior but sometimes is not that useful (it can also break R if you have many attributes). Maybe we just want to see where the data are located independent of any of the attributes. We can accomplish this by plotting only the geometry of the <code>sf</code> object.</p>
<pre class="r"><code>plot(alldat$geometry)</code></pre>
<p><img src="mapping_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<pre class="r"><code>plot(sgdat$geometry)</code></pre>
<p><img src="mapping_files/figure-html/unnamed-chunk-10-2.png" width="672" /></p>
<p>To emphasize the point that the <code>sf</code> package plays nice with the tidyverse, let’s do a simple filter on the fisheries data to look at only the 2016 data. This is the same year as the seagrass data.</p>
<pre class="r"><code>filt_dat &lt;- alldat %&gt;% 
  filter(yr == 2016)
plot(filt_dat$geometry)</code></pre>
<p><img src="mapping_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<p>Now let’s use the fisheries data and seagrass polygons to do a quick geospatial analysis. Our simple question is:</p>
<p><strong>How many fish were caught where seagrass was observed in 2016?</strong></p>
<p>The first task is to subset the 2016 fisheries data by locations where seagrass was observed. There are a few ways we can do this. The first is to make a simple subset where we filter the station locations using a spatial overlay with the seagrass polygons. With this approach we can see which stations were located over seagrass, but we don’t know which polygons they’re located in for the seagrass data.</p>
<pre class="r"><code>fish_crop &lt;- filt_dat[sgdat, ]
plot(fish_crop$geometry)</code></pre>
<p><img src="mapping_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<pre class="r"><code>fish_crop</code></pre>
<pre><code>## Simple feature collection with 145 features and 12 fields
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: -82.7182 ymin: 27.82623 xmax: -82.53237 ymax: 28.02418
## geographic CRS: WGS 84
## [90m# A tibble: 145 x 13[39m
##    OBJECTID Reference Sampling_Date    yr  Gear ExDate              Bluefish
##       [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m     [3m[90m&lt;date&gt;[39m[23m        [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dttm&gt;[39m[23m                 [3m[90m&lt;dbl&gt;[39m[23m
## [90m 1[39m  2[4m7[24m[4m3[24m[4m9[24m992 TBM20160… 2016-04-08     [4m2[24m016    20 2018-04-12 [90m11:06:24[39m        0
## [90m 2[39m  2[4m7[24m[4m4[24m[4m0[24m055 TBM20160… 2016-05-02     [4m2[24m016   160 2018-04-12 [90m11:06:24[39m        0
## [90m 3[39m  2[4m7[24m[4m4[24m[4m0[24m233 TBM20160… 2016-06-20     [4m2[24m016    20 2018-04-12 [90m11:06:40[39m        0
## [90m 4[39m  2[4m7[24m[4m4[24m[4m0[24m253 TBM20160… 2016-06-22     [4m2[24m016    20 2018-04-12 [90m11:06:40[39m        0
## [90m 5[39m  2[4m7[24m[4m4[24m[4m1[24m642 TBM20160… 2016-02-11     [4m2[24m016    20 2018-04-12 [90m11:06:13[39m        0
## [90m 6[39m  2[4m7[24m[4m4[24m[4m1[24m698 TBM20160… 2016-03-09     [4m2[24m016    20 2018-04-12 [90m11:06:13[39m        0
## [90m 7[39m  2[4m7[24m[4m4[24m[4m1[24m782 TBM20160… 2016-02-11     [4m2[24m016    20 2018-04-12 [90m11:06:03[39m        0
## [90m 8[39m  2[4m7[24m[4m4[24m[4m1[24m834 TBM20160… 2016-03-09     [4m2[24m016    20 2018-04-12 [90m11:06:04[39m        0
## [90m 9[39m  2[4m7[24m[4m4[24m[4m1[24m867 TBM20160… 2016-04-26     [4m2[24m016   160 2018-04-12 [90m11:06:16[39m        0
## [90m10[39m  2[4m7[24m[4m4[24m[4m2[24m220 TBM20160… 2016-05-17     [4m2[24m016    20 2018-04-12 [90m11:06:20[39m        0
## [90m# … with 135 more rows, and 6 more variables: `Common Snook` [3m[90m&lt;dbl&gt;[90m[23m,[39m
## [90m#   Mullets [3m[90m&lt;dbl&gt;[90m[23m, Pinfish [3m[90m&lt;dbl&gt;[90m[23m, `Red Drum` [3m[90m&lt;dbl&gt;[90m[23m, `Sand Seatrout` [3m[90m&lt;dbl&gt;[90m[23m,[39m
## [90m#   geometry [3m[90m&lt;POINT [°]&gt;[90m[23m[39m</code></pre>
<p>The second and more complete approach is to intersect the two data objects to subset and combine the attributes. We can use <code>st_intersection</code> to both overlay and combine the attribute fields from the two data objects.</p>
<pre class="r"><code>fish_int &lt;- st_intersection(alldat, sgdat)
plot(fish_int$geometry)</code></pre>
<p><img src="mapping_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<pre class="r"><code>fish_int</code></pre>
<pre><code>## Simple feature collection with 1770 features and 14 fields
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: -82.72437 ymin: 27.82277 xmax: -82.53105 ymax: 28.025
## geographic CRS: WGS 84
## [90m# A tibble: 1,770 x 15[39m
##    OBJECTID Reference Sampling_Date    yr  Gear ExDate              Bluefish
##  [90m*[39m    [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m     [3m[90m&lt;date&gt;[39m[23m        [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dttm&gt;[39m[23m                 [3m[90m&lt;dbl&gt;[39m[23m
## [90m 1[39m  1[4m6[24m[4m8[24m[4m2[24m543 TBM20040… 2004-01-02     [4m2[24m004    20 2018-04-12 [90m10:21:29[39m        0
## [90m 2[39m  1[4m8[24m[4m3[24m[4m3[24m156 TBM20041… 2004-11-24     [4m2[24m004    20 2018-04-12 [90m10:22:59[39m        0
## [90m 3[39m  2[4m0[24m[4m2[24m[4m9[24m572 TBM20010… 2001-03-23     [4m2[24m001    20 2018-04-12 [90m10:43:13[39m        0
## [90m 4[39m  2[4m2[24m[4m4[24m[4m8[24m030 TBM20020… 2002-09-03     [4m2[24m002    20 2018-04-12 [90m10:48:20[39m        0
## [90m 5[39m  2[4m4[24m[4m7[24m[4m5[24m686 TBM20070… 2007-06-11     [4m2[24m007    20 2018-04-12 [90m10:31:33[39m        0
## [90m 6[39m  2[4m6[24m[4m4[24m[4m0[24m416 TBD19961… 1996-10-15     [4m1[24m996   251 2018-04-12 [90m10:46:00[39m        0
## [90m 7[39m  2[4m6[24m[4m4[24m[4m2[24m233 TBD19961… 1996-10-15     [4m1[24m996   251 2018-04-12 [90m10:45:27[39m        0
## [90m 8[39m  2[4m6[24m[4m4[24m[4m2[24m326 TBD20001… 2000-10-24     [4m2[24m000   251 2018-04-12 [90m10:46:11[39m        0
## [90m 9[39m  2[4m6[24m[4m4[24m[4m3[24m460 TBD20041… 2004-10-26     [4m2[24m004   251 2018-04-12 [90m10:46:03[39m        0
## [90m10[39m  2[4m6[24m[4m4[24m[4m3[24m763 TBD19961… 1996-10-15     [4m1[24m996   251 2018-04-12 [90m10:45:15[39m        0
## [90m# … with 1,760 more rows, and 8 more variables: Common.Snook [3m[90m&lt;dbl&gt;[90m[23m,[39m
## [90m#   Mullets [3m[90m&lt;dbl&gt;[90m[23m, Pinfish [3m[90m&lt;dbl&gt;[90m[23m, Red.Drum [3m[90m&lt;dbl&gt;[90m[23m, Sand.Seatrout [3m[90m&lt;dbl&gt;[90m[23m,[39m
## [90m#   OBJECTID.1 [3m[90m&lt;int&gt;[90m[23m, FLUCCS [3m[90m&lt;chr&gt;[90m[23m, geometry [3m[90m&lt;POINT [°]&gt;[90m[23m[39m</code></pre>
<p>Now we can easily see which stations are in which seagrass polygon. We can use some familiar tools from dplyr to get the aggregate catch data for the different polygon counts. Specifically, the <code>FLUCCS</code> attribute identifies seagrass polygons as continuous (<code>9116</code>) or patchy (<code>9113</code>) (metadata <a href="https://www.arcgis.com/sharing/rest/content/items/f0ecff0cf0de491685f8fb074adb278b/info/metadata/metadata.xml?format=default&amp;output=html" target="_blank">here</a>). Maybe we want to summarise species counts by seagrass polygon type.</p>
<pre class="r"><code>fish_cnt &lt;- fish_int %&gt;% 
  group_by(FLUCCS) %&gt;% 
  summarise(
    cnt = sum(Pinfish)
  ) 
fish_cnt</code></pre>
<pre><code>## Simple feature collection with 2 features and 2 fields
## geometry type:  MULTIPOINT
## dimension:      XY
## bbox:           xmin: -82.72437 ymin: 27.82277 xmax: -82.53105 ymax: 28.025
## geographic CRS: WGS 84
## [90m# A tibble: 2 x 3[39m
##   FLUCCS   cnt                                                          geometry
##   [3m[90m&lt;chr&gt;[39m[23m  [3m[90m&lt;dbl&gt;[39m[23m                                                  [3m[90m&lt;MULTIPOINT [°]&gt;[39m[23m
## [90m1[39m 9113   [4m1[24m[4m9[24m212 ((-82.72388 27.94753), (-82.72377 27.94582), (-82.72373 27.94665…
## [90m2[39m 9116   [4m6[24m[4m1[24m531 ((-82.72437 27.93653), (-82.72283 27.9375), (-82.72258 27.93675)…</code></pre>
<p>Notice that we’ve retained the <code>sf</code> data structure in the aggregated dataset but the structure is now slightly different, both in the attributes and the geometry column. We now have only two attributes, <code>FLUCCS</code> and <code>cnt</code>. The <code>geometry</code> column is retained but now is aggregated to a multipoint object where all points in continous or patchy seagrass are grouped by row. This is a really powerful feature of <code>sf</code>: spatial attributes are retained during the wrangling process.</p>
<p>We can also visualize this information with ggplot2. This plot shows how many pinfish were caught in the two seagrass coverage categories for all of Old Tampa Bay (<code>9113</code>: patchy, <code>9116</code>: continuous).</p>
<pre class="r"><code>ggplot(fish_cnt, aes(x = FLUCCS, y = cnt)) + 
  geom_bar(stat = &#39;identity&#39;)</code></pre>
<p><img src="mapping_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>This is not a groundbreaking plot, but we can clearly see that pinfish are more often found in dense seagrass beds (<code>9116</code>).</p>
</div>
<div id="quick-mapping" class="section level2">
<h2>Quick mapping</h2>
<p>Cartography or map-making is also very doable in R. Like most applications, it takes very little time to create something simple, but much more time to create a finished product. We’ll focus on the simple process using <code>ggplot2</code> and the <code>mapview</code> package just to get you started. Both packages work “out-of-the-box” with <code>sf</code> data objects.</p>
<p>For <code>ggplot</code>, all we need is to use the <code>geom_sf()</code> geom.</p>
<pre class="r"><code># use ggplot with sf objects
ggplot() + 
  geom_sf(data = sgdat, fill = &#39;green&#39;) + 
  geom_sf(data = alldat) </code></pre>
<p><img src="mapping_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>The <code>mapview</code> packages lets us create interactive maps to zoom and select data. Note that we can also combine separate mapview objects with the <code>+</code> operator.</p>
<pre class="r"><code>mapview(sgdat, col.regions = &#39;green&#39;) +
  mapview(alldat, zcol = &#39;Gear&#39;)</code></pre>
<div id="htmlwidget-d0910e05e9f547772495" style="width:672px;height:480px;" class="leaflet html-widget"></div>
<script type="application/json" data-for="htmlwidget-d0910e05e9f547772495">{"x":{"options":{"minZoom":1,"maxZoom":52,"crs":{"crsClass":"L.CRS.EPSG3857","code":null,"proj4def":null,"projectedBounds":null,"options":{}},"preferCanvas":false,"bounceAtZoomLimits":false,"maxBounds":[[[-90,-370]],[[90,370]]]},"calls":[{"method":"addProviderTiles","args":["CartoDB.Positron","CartoDB.Positron","CartoDB.Positron",{"errorTileUrl":"","noWrap":false,"detectRetina":false,"pane":"tilePane"}]},{"method":"addProviderTiles","args":["CartoDB.DarkMatter","CartoDB.DarkMatter","CartoDB.DarkMatter",{"errorTileUrl":"","noWrap":false,"detectRetina":false,"pane":"tilePane"}]},{"method":"addProviderTiles","args":["OpenStreetMap","OpenStreetMap","OpenStreetMap",{"errorTileUrl":"","noWrap":false,"detectRetina":false,"pane":"tilePane"}]},{"method":"addProviderTiles","args":["Esri.WorldImagery","Esri.WorldImagery","Esri.WorldImagery",{"errorTileUrl":"","noWrap":false,"detectRetina":false,"pane":"tilePane"}]},{"method":"addProviderTiles","args":["OpenTopoMap","OpenTopoMap","OpenTopoMap",{"errorTileUrl":"","noWrap":false,"detectRetina":false,"pane":"tilePane"}]},{"method":"createMapPane","args":["polygon",420]},{"method":"addFlatGeoBuf","args":["sgdat","sgdat",null,true,"mvFeatureId",{"radius":6,"stroke":true,"color":"#333333","weight":0.5,"opacity":0.9,"fill":true,"fillColor":"#00FF00","fillOpacity":0.6},{"className":"","pane":"polygon"},"mapview-popup",{"radius":{"to":[3,15],"from":[3,15]},"weight":{"to":[1,10],"from":[1,10]},"opacity":{"to":[0,1],"from":[0,1]},"fillOpacity":{"to":[0,1],"from":[0,1]}}]},{"method":"addScaleBar","args":[{"maxWidth":100,"metric":true,"imperial":true,"updateWhenIdle":true,"position":"bottomleft"}]},{"method":"addHomeButton","args":[-82.7246245377676,27.8138561767142,-82.4842557811664,28.0354848221027,"sgdat","Zoom to sgdat","<strong> sgdat <\/strong>","bottomright"]},{"method":"addLegend","args":[{"colors":["#00FF00"],"labels":["sgdat"],"na_color":null,"na_label":"NA","opacity":1,"position":"topright","type":"factor","title":"","extra":null,"layerId":null,"className":"info legend","group":"sgdat"}]},{"method":"createMapPane","args":["point",440]},{"method":"addFlatGeoBuf","args":["alldat-Gear","alldat - Gear",null,true,"Gear",{"radius":6,"stroke":true,"color":"#333333","weight":1,"opacity":0.9,"fill":true,"fillColor":null,"fillOpacity":0.6},{"className":"","pane":"point"},"mapview-popup",{"radius":{"to":[3,15],"from":[3,15]},"weight":{"to":[1,10],"from":[1,10]},"opacity":{"to":[0,1],"from":[0,1]},"fillOpacity":{"to":[0,1],"from":[0,1]}}]},{"method":"addHomeButton","args":[-82.724366,27.822766,-82.53105,28.031183,"alldat - Gear","Zoom to alldat - Gear","<strong> alldat - Gear <\/strong>","bottomright"]},{"method":"addLayersControl","args":[["CartoDB.Positron","CartoDB.DarkMatter","OpenStreetMap","Esri.WorldImagery","OpenTopoMap"],["sgdat","alldat - Gear"],{"collapsed":true,"autoZIndex":true,"position":"topleft"}]},{"method":"addLegend","args":[{"colors":["#4B0055","#274983","#008298","#00B28A","#7ED357","#FDE333"],"labels":["20","22","160","251","300","301"],"na_color":null,"na_label":"NA","opacity":1,"position":"topright","type":"factor","title":"alldat - Gear","extra":null,"layerId":null,"className":"info legend","group":"alldat - Gear"}]},{"method":"addHomeButton","args":[-82.7246245377676,27.8138561767142,-82.4842557811664,28.0354848221027,null,"Zoom to full extent","<strong>Zoom full<\/strong>","bottomleft"]}],"fitBounds":[27.8138561767142,-82.7246245377676,28.0354848221027,-82.4842557811664,[]]},"evals":[],"jsHooks":{"render":[{"code":"function(el, x, data) {\n  return (\n      function(el, x, data) {\n      // get the leaflet map\n      var map = this; //HTMLWidgets.find('#' + el.id);\n      // we need a new div element because we have to handle\n      // the mouseover output separately\n      // debugger;\n      function addElement () {\n      // generate new div Element\n      var newDiv = $(document.createElement('div'));\n      // append at end of leaflet htmlwidget container\n      $(el).append(newDiv);\n      //provide ID and style\n      newDiv.addClass('lnlt');\n      newDiv.css({\n      'position': 'relative',\n      'bottomleft':  '0px',\n      'background-color': 'rgba(255, 255, 255, 0.7)',\n      'box-shadow': '0 0 2px #bbb',\n      'background-clip': 'padding-box',\n      'margin': '0',\n      'padding-left': '5px',\n      'color': '#333',\n      'font': '9px/1.5 \"Helvetica Neue\", Arial, Helvetica, sans-serif',\n      'z-index': '700',\n      });\n      return newDiv;\n      }\n\n\n      // check for already existing lnlt class to not duplicate\n      var lnlt = $(el).find('.lnlt');\n\n      if(!lnlt.length) {\n      lnlt = addElement();\n\n      // grab the special div we generated in the beginning\n      // and put the mousmove output there\n\n      map.on('mousemove', function (e) {\n      if (e.originalEvent.ctrlKey) {\n      if (document.querySelector('.lnlt') === null) lnlt = addElement();\n      lnlt.text(\n                           ' lon: ' + (e.latlng.lng).toFixed(5) +\n                           ' | lat: ' + (e.latlng.lat).toFixed(5) +\n                           ' | zoom: ' + map.getZoom() +\n                           ' | x: ' + L.CRS.EPSG3857.project(e.latlng).x.toFixed(0) +\n                           ' | y: ' + L.CRS.EPSG3857.project(e.latlng).y.toFixed(0) +\n                           ' | epsg: 3857 ' +\n                           ' | proj4: +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs ');\n      } else {\n      if (document.querySelector('.lnlt') === null) lnlt = addElement();\n      lnlt.text(\n                      ' lon: ' + (e.latlng.lng).toFixed(5) +\n                      ' | lat: ' + (e.latlng.lat).toFixed(5) +\n                      ' | zoom: ' + map.getZoom() + ' ');\n      }\n      });\n\n      // remove the lnlt div when mouse leaves map\n      map.on('mouseout', function (e) {\n      var strip = document.querySelector('.lnlt');\n      if( strip !==null) strip.remove();\n      });\n\n      };\n\n      //$(el).keypress(67, function(e) {\n      map.on('preclick', function(e) {\n      if (e.originalEvent.ctrlKey) {\n      if (document.querySelector('.lnlt') === null) lnlt = addElement();\n      lnlt.text(\n                      ' lon: ' + (e.latlng.lng).toFixed(5) +\n                      ' | lat: ' + (e.latlng.lat).toFixed(5) +\n                      ' | zoom: ' + map.getZoom() + ' ');\n      var txt = document.querySelector('.lnlt').textContent;\n      console.log(txt);\n      //txt.innerText.focus();\n      //txt.select();\n      setClipboardText('\"' + txt + '\"');\n      }\n      });\n\n      }\n      ).call(this.getMap(), el, x, data);\n}","data":null},{"code":"function(el, x, data) {\n  return (function(el,x,data){\n           var map = this;\n\n           map.on('keypress', function(e) {\n               console.log(e.originalEvent.code);\n               var key = e.originalEvent.code;\n               if (key === 'KeyE') {\n                   var bb = this.getBounds();\n                   var txt = JSON.stringify(bb);\n                   console.log(txt);\n\n                   setClipboardText('\\'' + txt + '\\'');\n               }\n           })\n        }).call(this.getMap(), el, x, data);\n}","data":null}]}}</script>
<p>There’s a lot more we can do with <code>mapview</code> but the point is that these maps are incredibly easy to make with <code>sf</code> objects and they offer a lot more functionality than static plots.</p>
</div>
<div id="exercise-14" class="section level2">
<h2>Exercise 14</h2>
<p>We’ve certainly covered a lot in this lesson, so we’ll spend any remaining time we have on getting more comfortable with basic geospatial analysis and mapping in R.</p>
<ol style="list-style-type: decimal">
<li><p>Start by creating an intersection of the <code>alldat</code> object you created in exercise 13 with the seagrass data. This is the same process shown in the examples above (e.g., <code>st_intersection(alldat, sgdat)</code>. Make sure to store the intersected object as a new variable in your workspace.</p></li>
<li><p>Create a map of this intersected object using <code>mapview()</code>. Use the <code>zcol</code> argument to map the color values to different attributes in your dataset, e.g., <code>Pinfish</code> or <code>Bluefish</code>.</p></li>
<li><p>Try combining the map you made in the last step with one for seagrass (hint: <code>mapview() + mapview()</code>).</p></li>
</ol>
<div class="fold s o">
<pre class="r"><code># intersect data
tomap &lt;- st_intersection(alldat, sgdat)

# make map
mapview(tomap, zcol = &#39;Pinfish&#39;)
mapview(tomap, zcol = &#39;Bluefish&#39;)

# join maps
mapview(sgdat) + mapview(tomap, zcol = &#39;Pinfish&#39;)</code></pre>
</div>
</div>
<div id="next-steps" class="section level2">
<h2>Next steps</h2>
<p>Now you should be able to:</p>
<ol style="list-style-type: decimal">
<li><p>Understand the vector data structure</p></li>
<li><p>Understand how to import and structure vector data in R</p></li>
<li><p>Understand how R stores spatial data using the simple features package</p></li>
<li><p>Execute basic geospatial functions in R</p></li>
</ol>
<p>This concludes our training workshop. I hope you’ve enjoyed the material and found the content useful. Please continue to use this website as a resource for developing your R skills and definitely checkout our <a href="Data_and_Resources.html">Data and Resources</a> page for additional learning material.</p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
